From 75ee155556c521b0a4157ee99e5eef73e70f8d29 Mon Sep 17 00:00:00 2001
From: Jiaxin Wu <Jiaxin.wu@intel.com>
Date: Thu, 24 Jan 2019 09:41:38 +0800
Subject: [PATCH v1] libredfish: Support libredfish under UEFI environment.

This patch is to support libredfish under UEFI environment:
*Replace libcurl with EFI REST EX protocol to provide basic query abilities.
*Refined the APIs to return the HTTP StatusCode.

Contributed-under: TianoCore Contribution Agreement 1.1
Signed-off-by: Wu Jiaxin <jiaxin.wu@intel.com>
---
 bindings/uefi/include/redfish.h        |   25 +
 bindings/uefi/include/redfishPayload.h |   35 +
 bindings/uefi/include/redfishService.h |   98 ++
 bindings/uefi/src/payload.c            |  731 +++++++++++
 bindings/uefi/src/service.c            | 1556 ++++++++++++++++++++++++
 src/redpath.c                          |   22 +-
 6 files changed, 2461 insertions(+), 6 deletions(-)
 create mode 100644 bindings/uefi/include/redfish.h
 create mode 100644 bindings/uefi/include/redfishPayload.h
 create mode 100644 bindings/uefi/include/redfishService.h
 create mode 100644 bindings/uefi/src/payload.c
 create mode 100644 bindings/uefi/src/service.c

diff --git a/bindings/uefi/include/redfish.h b/bindings/uefi/include/redfish.h
new file mode 100644
index 0000000..484f73a
--- /dev/null
+++ b/bindings/uefi/include/redfish.h
@@ -0,0 +1,25 @@
+/** @file
+
+  Copyright (c) 2019, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+//----------------------------------------------------------------------------
+// Copyright Notice:
+// Copyright 2017 Distributed Management Task Force, Inc. All rights reserved.
+// License: BSD 3-Clause License. For full text see link: https://github.com/DMTF/libredfish/LICENSE.md
+//----------------------------------------------------------------------------
+#ifndef _REDFISH_H_
+#define _REDFISH_H_
+
+#include <redfishService.h>
+#include <redfishPayload.h>
+#include "..\..\..\include\redpath.h"
+
+#endif
diff --git a/bindings/uefi/include/redfishPayload.h b/bindings/uefi/include/redfishPayload.h
new file mode 100644
index 0000000..3c1d4bf
--- /dev/null
+++ b/bindings/uefi/include/redfishPayload.h
@@ -0,0 +1,35 @@
+/** @file
+
+  Copyright (c) 2019, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+//----------------------------------------------------------------------------
+// Copyright Notice:
+// Copyright 2017 Distributed Management Task Force, Inc. All rights reserved.
+// License: BSD 3-Clause License. For full text see link: https://github.com/DMTF/libredfish/LICENSE.md
+//----------------------------------------------------------------------------
+#ifndef _REDFISH_PAYLOAD_H_
+#define _REDFISH_PAYLOAD_H_
+
+#include "redfishService.h"
+
+#include "..\..\..\include\redpath.h"
+
+redfishPayload* createRedfishPayload(json_t* value, redfishService* service);
+redfishPayload* getPayloadByNodeName(redfishPayload* payload, const char* nodeName, EFI_HTTP_STATUS_CODE** StatusCode);
+redfishPayload* getPayloadByIndex(redfishPayload* payload, size_t index, EFI_HTTP_STATUS_CODE** StatusCode);
+redfishPayload* getPayloadForPath(redfishPayload* payload, redPathNode* redpath, EFI_HTTP_STATUS_CODE** StatusCode);
+redfishPayload* getPayloadForPathString(redfishPayload* payload, const char* string, EFI_HTTP_STATUS_CODE** StatusCode);
+redfishPayload* patchPayload(redfishPayload* target, redfishPayload* payload, EFI_HTTP_STATUS_CODE** StatusCode);
+redfishPayload* postContentToPayload(redfishPayload* target, const char* data, size_t dataSize, const char* contentType, EFI_HTTP_STATUS_CODE** StatusCode);
+redfishPayload* postPayload(redfishPayload* target, redfishPayload* payload, EFI_HTTP_STATUS_CODE** StatusCode);
+void            cleanupPayload(redfishPayload* payload);
+
+#endif
diff --git a/bindings/uefi/include/redfishService.h b/bindings/uefi/include/redfishService.h
new file mode 100644
index 0000000..5d5958e
--- /dev/null
+++ b/bindings/uefi/include/redfishService.h
@@ -0,0 +1,98 @@
+/** @file
+
+  Copyright (c) 2019, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+//----------------------------------------------------------------------------
+// Copyright Notice:
+// Copyright 2017 Distributed Management Task Force, Inc. All rights reserved.
+// License: BSD 3-Clause License. For full text see link: https://github.com/DMTF/libredfish/LICENSE.md
+//----------------------------------------------------------------------------
+#ifndef _REDFISH_SERVICE_H_
+#define _REDFISH_SERVICE_H_
+
+#include <Library/BaseLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/UefiRuntimeServicesTableLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/HttpLib.h>
+#include <Library/NetLib.h>
+#include <jansson.h>
+#include <Protocol/RestEx.h>
+#include <IndustryStandard/RedfishHostInterface.h>
+
+typedef struct {
+    char* host;
+    json_t* versions;
+    unsigned int flags;
+    char* sessionToken;
+    char* basicAuthStr;
+    //
+    // point to the <HOST> part in above "host" field, which will be put into
+    // the "Host" header of HTTP request message.
+    //
+    char* HostHeaderValue;
+
+    EFI_HANDLE           Image;
+    EFI_HANDLE           Controller;
+
+    EFI_HANDLE           ChildHandle;
+    EFI_REST_EX_PROTOCOL *RestEx;
+} redfishService;
+
+typedef struct {
+    json_t* json;
+    redfishService* service;
+} redfishPayload;
+
+#define REDFISH_AUTH_BASIC        0
+#define REDFISH_AUTH_BEARER_TOKEN 1
+#define REDFISH_AUTH_SESSION      2
+
+#define REDFISH_HTTP_RESPONSE_TIMEOUT   5000      /// 5 seconds in uints of millisecond.
+
+///
+/// Library class public defines
+///
+#define HTTP_FLAG                  L"http://"
+#define HTTPS_FLAG                 L"https://"
+
+///
+/// The redfish first URL should be "/redfish/v1/", while we use "/redfish/v1" here without "/"
+/// in the end is to avoid the 301 Perment redirect response from Redfish profile simulator.
+///
+#define REDFISH_FIRST_URL          L"/redfish/v1"
+
+typedef struct {
+        unsigned int authType;
+        union {
+            struct {
+                char* username;
+                char* password;
+            } userPass;
+            struct {
+                char* token;
+            } authToken;
+        } authCodes;
+} enumeratorAuthentication;
+
+//Values for flags
+#define REDFISH_FLAG_SERVICE_NO_VERSION_DOC 0x00000001 //The Redfish Service lacks the version document (in violation of the Redfish spec)
+redfishService* createServiceEnumerator(EFI_HANDLE Image, EFI_HANDLE Controller, REDFISH_OVER_IP_PROTOCOL_DATA *RedfishData, const char* rootUri, enumeratorAuthentication* auth, unsigned int flags);
+json_t* getUriFromService(redfishService* service, const char* uri, EFI_HTTP_STATUS_CODE** StatusCode);
+json_t* patchUriFromService(redfishService* service, const char* uri, const char* content, EFI_HTTP_STATUS_CODE** StatusCode);
+json_t* postUriFromService(redfishService* service, const char* uri, const char* content, size_t contentLength, const char* contentType, EFI_HTTP_STATUS_CODE** StatusCode);
+json_t* deleteUriFromService(redfishService* service, const char* uri, EFI_HTTP_STATUS_CODE** StatusCode);
+redfishPayload* getRedfishServiceRoot(redfishService* service, const char* version, EFI_HTTP_STATUS_CODE** StatusCode);
+redfishPayload* getPayloadByPath(redfishService* service, const char* path, EFI_HTTP_STATUS_CODE** StatusCode);
+void cleanupServiceEnumerator(redfishService* service);
+
+#endif
diff --git a/bindings/uefi/src/payload.c b/bindings/uefi/src/payload.c
new file mode 100644
index 0000000..14dc4c4
--- /dev/null
+++ b/bindings/uefi/src/payload.c
@@ -0,0 +1,731 @@
+/** @file
+
+  Copyright (c) 2019, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+//----------------------------------------------------------------------------
+// Copyright Notice:
+// Copyright 2017 Distributed Management Task Force, Inc. All rights reserved.
+// License: BSD 3-Clause License. For full text see link: https://github.com/DMTF/libredfish/LICENSE.md
+//----------------------------------------------------------------------------
+#include "redfishPayload.h"
+
+static redfishPayload* getOpResult(redfishPayload* payload, const char* propName, const char* op, const char* value, EFI_HTTP_STATUS_CODE** StatusCode);
+static redfishPayload* collectionEvalOp(redfishPayload* payload, const char* propName, const char* op, const char* value, EFI_HTTP_STATUS_CODE** StatusCode);
+static redfishPayload* arrayEvalOp(redfishPayload* payload, const char* propName, const char* op, const char* value, EFI_HTTP_STATUS_CODE** StatusCode);
+static redfishPayload* createCollection(redfishService* service, size_t count, redfishPayload** payloads);
+static json_t*         json_object_get_by_index(json_t* json, size_t index);
+
+bool isPayloadCollection(redfishPayload* payload)
+{
+    json_t* members;
+    json_t* count;
+
+    if(!payload || !json_is_object(payload->json))
+    {
+        return false;
+    }
+    members = json_object_get(payload->json, "Members");
+    count = json_object_get(payload->json, "Members@odata.count");
+    return ((members != NULL) && (count != NULL));
+}
+
+size_t getCollectionSize(redfishPayload* payload)
+{
+    json_t* members;
+    json_t* count;
+
+    if(!payload || !json_is_object(payload->json))
+    {
+        return 0;
+    }
+    members = json_object_get(payload->json, "Members");
+    count = json_object_get(payload->json, "Members@odata.count");
+    if(!members || !count)
+    {
+        return 0;
+    }
+    return (size_t)json_integer_value(count);
+}
+
+bool isPayloadArray(redfishPayload* payload)
+{
+    if(!payload || !json_is_array(payload->json))
+    {
+        return false;
+    }
+    return true;
+}
+
+char* payloadToString(redfishPayload* payload, bool prettyPrint)
+{
+    size_t flags = 0;
+    if(!payload)
+    {
+        return NULL;
+    }
+    if(prettyPrint)
+    {
+        flags = JSON_INDENT(2);
+    }
+    return json_dumps(payload->json, flags);
+}
+
+redfishPayload* createRedfishPayload(json_t* value, redfishService* service)
+{
+    redfishPayload* payload;
+    payload = (redfishPayload*)malloc(sizeof(redfishPayload));
+    if(payload != NULL)
+    {
+        payload->json = value;
+        payload->service = service;
+    }
+    return payload;
+}
+
+redfishPayload* getPayloadByNodeName(redfishPayload* payload, const char* nodeName, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+    json_t* value;
+    json_t* odataId;
+    const char* uri;
+
+    if(!payload || !nodeName || StatusCode == NULL)
+    {
+        return NULL;
+    }
+
+    *StatusCode = NULL;
+
+    value = json_object_get(payload->json, nodeName);
+    if(value == NULL)
+    {
+        return NULL;
+    }
+    json_incref(value);
+    if(json_object_size(value) == 1)
+    {
+        odataId = json_object_get(value, "@odata.id");
+        if(odataId != NULL)
+        {
+            json_incref(odataId);
+            uri = json_string_value(odataId);
+            json_decref(value);
+            value = getUriFromService(payload->service, uri, StatusCode);
+            json_decref(odataId);
+            if(value == NULL || *StatusCode == NULL)
+            {
+              return NULL;
+            }
+        }
+    }
+    if (*StatusCode == NULL || (**StatusCode >= HTTP_STATUS_200_OK && **StatusCode <= HTTP_STATUS_206_PARTIAL_CONTENT)) {
+      if(json_is_string(value))
+      {
+          odataId = json_object();
+          json_object_set(odataId, nodeName, value);
+          json_decref(value);
+          value = odataId;
+      }
+    }
+
+    return createRedfishPayload(value, payload->service);
+}
+
+redfishPayload* getPayloadByIndex(redfishPayload* payload, size_t index, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+    json_t* value = NULL;
+    json_t* odataId;
+    const char* uri;
+    BOOLEAN FromServerFlag = FALSE;
+
+    if(!payload || StatusCode == NULL)
+    {
+        return NULL;
+    }
+
+    *StatusCode = NULL;
+
+    if(isPayloadCollection(payload))
+    {
+        redfishPayload* members = getPayloadByNodeName(payload, "Members", StatusCode);
+        if ((*StatusCode == NULL && members == NULL) ||
+            (*StatusCode != NULL && (**StatusCode < HTTP_STATUS_200_OK || **StatusCode > HTTP_STATUS_206_PARTIAL_CONTENT))) {
+          return members;
+        }
+
+        if (*StatusCode != NULL) {
+          //
+          // The Payload (members) are retrived from server.
+          //
+          FreePool (*StatusCode);
+          *StatusCode = NULL;
+          FromServerFlag = TRUE;
+        }
+
+        redfishPayload* ret = getPayloadByIndex(members, index, StatusCode);
+        if (*StatusCode == NULL && ret != NULL && FromServerFlag) {
+          //
+          // In such a case, the Redfish resource is parsed from the input payload (members) directly.
+          // Since the members are retrived from server, we still return HTTP_STATUS_200_OK.
+          //
+          *StatusCode = AllocateZeroPool (sizeof (EFI_HTTP_STATUS_CODE));
+          if (*StatusCode == NULL) {
+            ret = NULL;
+          } else {
+            **StatusCode = HTTP_STATUS_200_OK;
+          }
+        }
+
+        cleanupPayload(members);
+        return ret;
+    }
+
+    if(json_is_array(payload->json))
+    {
+        //
+        // The valid range for index is from 0 to the return value of json_array_size() minus 1
+        //
+        value = json_array_get(payload->json, index);
+    }
+    else if(json_is_object(payload->json))
+    {
+        value = json_object_get_by_index(payload->json, index);
+    }
+
+    if(value == NULL)
+    {
+        return NULL;
+    }
+
+    json_incref(value);
+    if(json_object_size(value) == 1)
+    {
+        odataId = json_object_get(value, "@odata.id");
+        if(odataId != NULL)
+        {
+            uri = json_string_value(odataId);
+            json_decref(value);
+            value = getUriFromService(payload->service, uri, StatusCode);
+            if(value == NULL)
+            {
+                return NULL;
+            }
+        }
+    }
+    return createRedfishPayload(value, payload->service);
+}
+
+redfishPayload* getPayloadForPath(redfishPayload* payload, redPathNode* redpath, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+    redfishPayload* ret = NULL;
+    redfishPayload* tmp;
+
+    if(!payload || !redpath || StatusCode == NULL)
+    {
+        return NULL;
+    }
+
+    *StatusCode = NULL;
+    BOOLEAN FromServerFlag = FALSE;
+
+    if(redpath->nodeName)
+    {
+        ret = getPayloadByNodeName(payload, redpath->nodeName, StatusCode);
+        if ((*StatusCode == NULL && ret == NULL) ||
+            (*StatusCode != NULL && (**StatusCode < HTTP_STATUS_200_OK || **StatusCode > HTTP_STATUS_206_PARTIAL_CONTENT))) {
+            //
+            // Any error happen, return directly.
+            //
+          return ret;
+        }
+    }
+    else if(redpath->isIndex)
+    {
+        ASSERT (redpath->index >= 1);
+        ret = getPayloadByIndex(payload, redpath->index - 1, StatusCode);
+        if ((*StatusCode == NULL && ret == NULL) ||
+            (*StatusCode != NULL && (**StatusCode < HTTP_STATUS_200_OK || **StatusCode > HTTP_STATUS_206_PARTIAL_CONTENT))) {
+            //
+            // Any error happen, return directly.
+            //
+          return ret;
+        }
+    }
+    else if(redpath->op)
+    {
+        ret = getOpResult(payload, redpath->propName, redpath->op, redpath->value, StatusCode);
+        if ((*StatusCode == NULL && ret == NULL) ||
+            (*StatusCode != NULL && (**StatusCode < HTTP_STATUS_200_OK || **StatusCode > HTTP_STATUS_206_PARTIAL_CONTENT))) {
+            //
+            // Any error happen, return directly.
+            //
+          return ret;
+        }
+    }
+    else
+    {
+        return NULL;
+    }
+
+    if(redpath->next == NULL || ret == NULL)
+    {
+        return ret;
+    }
+    else
+    {
+        if (*StatusCode != NULL) {
+          FreePool (*StatusCode);
+          *StatusCode = NULL;
+          FromServerFlag = TRUE;
+        }
+
+        tmp = getPayloadForPath(ret, redpath->next, StatusCode);
+        if (*StatusCode == NULL && tmp != NULL && FromServerFlag) {
+          //
+          // In such a case, the Redfish resource is parsed from the input payload (ret) directly.
+          // Since the ret are retrived from server, we still return HTTP_STATUS_200_OK.
+          //
+          *StatusCode = AllocateZeroPool (sizeof (EFI_HTTP_STATUS_CODE));
+          if (*StatusCode == NULL) {
+            tmp = NULL;
+          } else {
+            **StatusCode = HTTP_STATUS_200_OK;
+          }
+        }
+
+        cleanupPayload(ret);
+        return tmp;
+    }
+}
+
+redfishPayload* getPayloadForPathString(redfishPayload* payload, const char* string, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+    redPathNode* redpath;
+    redfishPayload* ret;
+
+    if(!string || StatusCode == NULL)
+    {
+        return NULL;
+    }
+
+    *StatusCode = NULL;
+
+    redpath = parseRedPath(string);
+    if(redpath == NULL)
+    {
+        return NULL;
+    }
+    ret = getPayloadForPath(payload, redpath, StatusCode);
+    cleanupRedPath(redpath);
+    return ret;
+}
+
+redfishPayload* patchPayload(redfishPayload* target, redfishPayload* payload, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+  json_t* json;
+  char* content;
+  char* uri;
+
+  if(!target || !payload || StatusCode == NULL)
+  {
+    return NULL;
+  }
+
+  *StatusCode = NULL;
+
+  json = json_object_get(target->json, "@odata.id");
+  if(json == NULL)
+  {
+    return NULL;
+  }
+  uri = strdup(json_string_value(json));
+
+  content = json_dumps(payload->json, 0);
+  json_decref(json);
+
+  json = patchUriFromService(target->service, uri, content, StatusCode);
+  free(uri);
+  free(content);
+  if(json == NULL)
+  {
+    return NULL;
+  }
+
+  return createRedfishPayload(json, target->service);
+}
+
+redfishPayload* postContentToPayload(redfishPayload* target, const char* data, size_t dataSize, const char* contentType, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+    json_t* json;
+    char* uri;
+
+    if(!target || !data || StatusCode == NULL)
+    {
+        return NULL;
+    }
+
+    *StatusCode = NULL;
+
+    json = json_object_get(target->json, "@odata.id");
+    if(json == NULL)
+    {
+        json = json_object_get(target->json, "target");
+        if(json == NULL)
+        {
+            return NULL;
+        }
+    }
+    uri = strdup(json_string_value(json));
+    json = postUriFromService(target->service, uri, data, dataSize, contentType, StatusCode);
+    free(uri);
+    if(json == NULL)
+    {
+        return NULL;
+    }
+
+    return createRedfishPayload(json, target->service);
+}
+
+redfishPayload* postPayload(redfishPayload* target, redfishPayload* payload, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+    char* content;
+    redfishPayload* ret;
+
+    if(!target || !payload || StatusCode == NULL)
+    {
+        return NULL;
+    }
+
+    *StatusCode = NULL;
+
+    if(!json_is_object(payload->json))
+    {
+        return NULL;
+    }
+    content = payloadToString(payload, false);
+    ret = postContentToPayload(target, content, strlen(content), NULL, StatusCode);
+    free(content);
+    return ret;
+}
+
+void cleanupPayload(redfishPayload* payload)
+{
+    if(!payload)
+    {
+        return;
+    }
+    json_decref(payload->json);
+    //Don't free payload->service, let the caller handle cleaning up the service
+    free(payload);
+}
+
+static redfishPayload* getOpResult(redfishPayload* payload, const char* propName, const char* op, const char* value, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+    const char* propStr;
+    json_t* stringProp;
+    bool ret = false;
+    redfishPayload* prop;
+    long long intVal, intPropVal;
+
+    if(isPayloadCollection(payload))
+    {
+        return collectionEvalOp(payload, propName, op, value, StatusCode);
+    }
+    if(isPayloadArray(payload))
+    {
+        return arrayEvalOp(payload, propName, op, value, StatusCode);
+    }
+
+    prop = getPayloadByNodeName(payload, propName, StatusCode);
+    if ((*StatusCode == NULL && prop == NULL) ||
+        (*StatusCode != NULL && (**StatusCode < HTTP_STATUS_200_OK || **StatusCode > HTTP_STATUS_206_PARTIAL_CONTENT))) {
+      return prop;
+    }
+    stringProp = prop->json;
+    switch(json_typeof(prop->json))
+    {
+        case JSON_OBJECT:
+            stringProp = json_object_get(prop->json, propName);
+        case JSON_STRING:
+            if(strcmp(op, "=") == 0)
+            {
+                propStr = json_string_value(stringProp);
+                if(propStr == NULL)
+                {
+                    cleanupPayload(prop);
+                    return NULL;
+                }
+                ret = (strcmp(propStr, value) == 0);
+            } else if(strcmp(op, "~") == 0)
+            {
+                propStr = json_string_value(stringProp);
+                if(propStr == NULL)
+                {
+                    cleanupPayload(prop);
+                    return NULL;
+                }
+                ret = (strcasecmp(propStr, value) == 0);
+            }
+            break;
+        case JSON_TRUE:
+            if(strcmp(op, "=") == 0)
+            {
+                ret = (strcmp(value, "true") == 0);
+            }
+            break;
+        case JSON_FALSE:
+            if(strcmp(op, "=") == 0)
+            {
+                ret = (strcmp(value, "false") == 0);
+            }
+            break;
+        case JSON_INTEGER:
+            intPropVal = json_integer_value(prop->json);
+            intVal = strtoll(value, NULL, 0);
+            if(strcmp(op, "=") == 0)
+            {
+                ret = (intPropVal == intVal);
+            }
+            else if(strcmp(op, "<") == 0)
+            {
+                ret = (intPropVal < intVal);
+            }
+            else if(strcmp(op, ">") == 0)
+            {
+                ret = (intPropVal > intVal);
+            }
+            else if(strcmp(op, "<=") == 0)
+            {
+                ret = (intPropVal <= intVal);
+            }
+            else if(strcmp(op, ">=") == 0)
+            {
+                ret = (intPropVal >= intVal);
+            }
+            break;
+        default:
+            break;
+    }
+    cleanupPayload(prop);
+    if(ret)
+    {
+        return payload;
+    }
+    else
+    {
+        return NULL;
+    }
+}
+
+static redfishPayload* collectionEvalOp(redfishPayload* payload, const char* propName, const char* op, const char* value, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+    redfishPayload* ret;
+    redfishPayload* tmp;
+    redfishPayload* members;
+    redfishPayload** valid;
+    size_t validMax;
+    size_t validCount = 0;
+    size_t i;
+
+    validMax = getCollectionSize(payload);
+    if(validMax == 0)
+    {
+        return NULL;
+    }
+
+    valid = (redfishPayload**)calloc(validMax, sizeof(redfishPayload*));
+    if(valid == NULL)
+    {
+        return NULL;
+    }
+    /*Technically getPayloadByIndex would do this, but this optimizes things*/
+    members = getPayloadByNodeName(payload, "Members", StatusCode);
+    if ((*StatusCode == NULL && members == NULL) ||
+        (*StatusCode != NULL && (**StatusCode < HTTP_STATUS_200_OK || **StatusCode > HTTP_STATUS_206_PARTIAL_CONTENT))) {
+      return members;
+    }
+
+    for(i = 0; i < validMax; i++)
+    {
+        if (*StatusCode != NULL) {
+          FreePool (*StatusCode);
+          *StatusCode = NULL;
+        }
+
+        tmp = getPayloadByIndex(members, i, StatusCode);
+        if ((*StatusCode == NULL && tmp == NULL) ||
+            (*StatusCode != NULL && (**StatusCode < HTTP_STATUS_200_OK || **StatusCode > HTTP_STATUS_206_PARTIAL_CONTENT))) {
+          return tmp;
+        }
+
+        if (*StatusCode != NULL) {
+          FreePool (*StatusCode);
+          *StatusCode = NULL;
+        }
+
+        valid[validCount] = getOpResult(tmp, propName, op, value, StatusCode);
+        /*
+        if ((*StatusCode == NULL && valid[validCount] == NULL) ||
+            (*StatusCode != NULL && (**StatusCode < HTTP_STATUS_200_OK || **StatusCode > HTTP_STATUS_206_PARTIAL_CONTENT))) {
+          return valid[validCount];
+        }
+        */
+        if(valid[validCount] != NULL)
+        {
+            validCount++;
+        }
+        else
+        {
+            cleanupPayload(tmp);
+        }
+    }
+    cleanupPayload(members);
+    if(validCount == 0)
+    {
+        free(valid);
+        return NULL;
+    }
+    if(validCount == 1)
+    {
+        ret = valid[0];
+        free(valid);
+        return ret;
+    }
+    else
+    {
+        ret = createCollection(payload->service, validCount, valid);
+        free(valid);
+        return ret;
+    }
+}
+
+static redfishPayload* arrayEvalOp(redfishPayload* payload, const char* propName, const char* op, const char* value, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+    redfishPayload* ret;
+    redfishPayload* tmp;
+    redfishPayload** valid;
+    size_t validMax;
+    size_t validCount = 0;
+    size_t i;
+
+    validMax = json_array_size(payload->json);
+    if(validMax == 0)
+    {
+        return NULL;
+    }
+
+    valid = (redfishPayload**)calloc(validMax, sizeof(redfishPayload*));
+    if(valid == NULL)
+    {
+        return NULL;
+    }
+    for(i = 0; i < validMax; i++)
+    {
+        if (*StatusCode != NULL) {
+          FreePool (*StatusCode);
+          *StatusCode = NULL;
+        }
+
+        tmp = getPayloadByIndex(payload, i, StatusCode);
+        if ((*StatusCode == NULL && tmp == NULL) ||
+            (*StatusCode != NULL && (**StatusCode < HTTP_STATUS_200_OK || **StatusCode > HTTP_STATUS_206_PARTIAL_CONTENT))) {
+          return tmp;
+        }
+
+        if (*StatusCode != NULL) {
+          FreePool (*StatusCode);
+          *StatusCode = NULL;
+        }
+
+        valid[validCount] = getOpResult(tmp, propName, op, value, StatusCode);
+        /*
+        if ((*StatusCode == NULL && valid[validCount] == NULL) ||
+            (*StatusCode != NULL && (**StatusCode < HTTP_STATUS_200_OK || **StatusCode > HTTP_STATUS_206_PARTIAL_CONTENT))) {
+          return valid[validCount];
+        }
+        */
+
+        if(valid[validCount] != NULL)
+        {
+            validCount++;
+        }
+        else
+        {
+            cleanupPayload(tmp);
+        }
+    }
+    if(validCount == 0)
+    {
+        free(valid);
+        return NULL;
+    }
+    if(validCount == 1)
+    {
+        ret = valid[0];
+        free(valid);
+        return ret;
+    }
+    else
+    {
+        ret = createCollection(payload->service, validCount, valid);
+        free(valid);
+        return ret;
+    }
+}
+
+static redfishPayload* createCollection(redfishService* service, size_t count, redfishPayload** payloads)
+{
+    redfishPayload* ret;
+    json_t* collectionJson = json_object();
+    json_t* jcount = json_integer((json_int_t)count);
+    json_t* members = json_array();
+    size_t i;
+
+    if(!collectionJson)
+    {
+        return NULL;
+    }
+    if(!members)
+    {
+        json_decref(collectionJson);
+        return NULL;
+    }
+    json_object_set(collectionJson, "Members@odata.count", jcount);
+    json_decref(jcount);
+    for(i = 0; i < count; i++)
+    {
+        json_array_append(members, payloads[i]->json);
+        cleanupPayload(payloads[i]);
+    }
+    json_object_set(collectionJson, "Members", members);
+    json_decref(members);
+
+    ret = createRedfishPayload(collectionJson, service);
+    return ret;
+}
+
+static json_t* json_object_get_by_index(json_t* json, size_t index)
+{
+    void* iter;
+    size_t i;
+
+    iter = json_object_iter(json);
+    for(i = 0; i < index; i++)
+    {
+        iter = json_object_iter_next(json, iter);
+        if(iter == NULL) break;
+    }
+    if(iter == NULL)
+    {
+        return NULL;
+    }
+    return json_object_iter_value(iter);
+}
+/* vim: set tabstop=4 shiftwidth=4 expandtab: */
diff --git a/bindings/uefi/src/service.c b/bindings/uefi/src/service.c
new file mode 100644
index 0000000..3f48804
--- /dev/null
+++ b/bindings/uefi/src/service.c
@@ -0,0 +1,1556 @@
+/** @file
+
+  Copyright (c) 2019, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+//----------------------------------------------------------------------------
+// Copyright Notice:
+// Copyright 2017 Distributed Management Task Force, Inc. All rights reserved.
+// License: BSD 3-Clause License. For full text see link: https://github.com/DMTF/libredfish/LICENSE.md
+//----------------------------------------------------------------------------
+#include <redfishService.h>
+#include <redfishPayload.h>
+#include "..\..\..\include\redpath.h"
+
+static int initRest(redfishService* service, void * restProtocol);
+static redfishService* createServiceEnumeratorNoAuth(const char* host, const char* rootUri, bool enumerate, unsigned int flags, void * restProtocol);
+static redfishService* createServiceEnumeratorBasicAuth(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, void * restProtocol);
+static redfishService* createServiceEnumeratorSessionAuth(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, void * restProtocol);
+static char* makeUrlForService(redfishService* service, const char* uri);
+static json_t* getVersions(redfishService* service, const char* rootUri);
+static void addStringToJsonObject(json_t* object, const char* key, const char* value);
+
+CHAR16*
+C8ToC16 (CHAR8 *AsciiStr)
+{
+  CHAR16   *Str;
+  UINTN   BufLen;
+
+  BufLen = (AsciiStrLen (AsciiStr) + 1) * 2;
+  Str = AllocatePool (BufLen);
+  ASSERT (Str != NULL);
+
+  AsciiStrToUnicodeStrS (AsciiStr, Str, AsciiStrLen (AsciiStr) + 1);
+
+  return Str;
+}
+
+VOID
+RestConfigFreeHttpRequestData (
+  IN EFI_HTTP_REQUEST_DATA        *RequestData
+  )
+{
+  if (RequestData == NULL) {
+    return ;
+  }
+
+  if (RequestData->Url != NULL) {
+    FreePool (RequestData->Url);
+  }
+
+  FreePool (RequestData);
+}
+
+VOID
+RestConfigFreeHttpMessage (
+  IN EFI_HTTP_MESSAGE             *Message,
+  IN BOOLEAN                      IsRequest
+  )
+{
+  if (Message == NULL) {
+    return ;
+  }
+
+  if (IsRequest) {
+    RestConfigFreeHttpRequestData (Message->Data.Request);
+    Message->Data.Request = NULL;
+  } else {
+    if (Message->Data.Response != NULL) {
+      FreePool (Message->Data.Response);
+      Message->Data.Response = NULL;
+    }
+  }
+
+  if (Message->Headers != NULL) {
+    FreePool (Message->Headers);
+    Message->Headers = NULL;
+  }
+  if (Message->Body != NULL) {
+    FreePool (Message->Body);
+    Message->Body = NULL;
+  }
+}
+
+/**
+  Configure a REST EX protocol according to the Redfish network host interface record.
+
+  @param[in]       RestEx                A pointer to the REST EX protocol.
+  @param[in]       RedfishData           Redfish network host interface record.
+  @param[in]       ReceiveTimeout        HTTP response time out in uints of millisecond.
+
+  @retval EFI_SUCCESS           The REST EX was successfully configured.
+  @retval Others                Failed to configure the REST EX protocol.
+
+**/
+EFI_STATUS
+RedfishConfigRestEx (
+  IN EFI_REST_EX_PROTOCOL            *RestEx,
+  IN REDFISH_OVER_IP_PROTOCOL_DATA   *RedfishData,
+  IN UINT32                          ReceiveTimeout
+  )
+{
+  EFI_STATUS                        Status;
+  EFI_REST_EX_HTTP_CONFIG_DATA      *RestExHttpConfigData;
+
+  if (RestEx == NULL || RedfishData == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  RestExHttpConfigData = AllocateZeroPool (sizeof (EFI_REST_EX_HTTP_CONFIG_DATA));
+  if (RestExHttpConfigData == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  RestExHttpConfigData->SendReceiveTimeout = ReceiveTimeout;
+
+  RestExHttpConfigData->HttpConfigData.HttpVersion = HttpVersion11;
+  RestExHttpConfigData->HttpConfigData.LocalAddressIsIPv6 = (RedfishData->HostIpAddressFormat == REDFISH_HOST_INTERFACE_HOST_IP_ADDRESS_FORMAT_IP6) ? TRUE: FALSE;
+
+  if (RestExHttpConfigData->HttpConfigData.LocalAddressIsIPv6) {
+    RestExHttpConfigData->HttpConfigData.AccessPoint.IPv6Node = AllocateZeroPool (sizeof (EFI_HTTPv6_ACCESS_POINT));
+    if (RestExHttpConfigData->HttpConfigData.AccessPoint.IPv6Node == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+      goto ON_EXIT;
+    }
+
+    IP6_COPY_ADDRESS (&RestExHttpConfigData->HttpConfigData.AccessPoint.IPv6Node->LocalAddress, RedfishData->HostIpAddress);
+  } else {
+    RestExHttpConfigData->HttpConfigData.AccessPoint.IPv4Node = AllocateZeroPool (sizeof (EFI_HTTPv4_ACCESS_POINT));
+    if (RestExHttpConfigData->HttpConfigData.AccessPoint.IPv4Node == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+      goto ON_EXIT;
+    }
+    if (RedfishData->HostIpAssignmentType == 1) {
+      RestExHttpConfigData->HttpConfigData.AccessPoint.IPv4Node->UseDefaultAddress = FALSE;
+      IP4_COPY_ADDRESS (&RestExHttpConfigData->HttpConfigData.AccessPoint.IPv4Node->LocalAddress, RedfishData->HostIpAddress);
+      IP4_COPY_ADDRESS (&RestExHttpConfigData->HttpConfigData.AccessPoint.IPv4Node->LocalSubnet, RedfishData->HostIpMask);
+    } else if (RedfishData->HostIpAssignmentType == 3) {
+      RestExHttpConfigData->HttpConfigData.AccessPoint.IPv4Node->UseDefaultAddress = TRUE;
+    } else {
+      Status = EFI_UNSUPPORTED;
+      goto ON_EXIT;
+    }
+  }
+
+  Status = RestEx->Configure (
+                     RestEx,
+                     (EFI_REST_EX_CONFIG_DATA)(UINT8 *)RestExHttpConfigData
+                     );
+  if (EFI_ERROR (Status)) {
+    goto ON_EXIT;
+  }
+
+ON_EXIT:
+
+  if (RestExHttpConfigData != NULL) {
+    if (RestExHttpConfigData->HttpConfigData.LocalAddressIsIPv6 && RestExHttpConfigData->HttpConfigData.AccessPoint.IPv6Node != NULL) {
+      FreePool (RestExHttpConfigData->HttpConfigData.AccessPoint.IPv6Node);
+    }
+
+    if (!RestExHttpConfigData->HttpConfigData.LocalAddressIsIPv6 && RestExHttpConfigData->HttpConfigData.AccessPoint.IPv4Node != NULL) {
+      FreePool (RestExHttpConfigData->HttpConfigData.AccessPoint.IPv4Node);
+    }
+
+    FreePool (RestExHttpConfigData);
+  }
+
+  return Status;
+}
+
+/**
+  Destroy a child of the REST EX service.
+
+  @param[in]   Image                 The image handle used to open service.
+  @param[in]   Controller            The controller which has the service installed.
+  @param[in]   ChildHandle           The child to destroy.
+  @param[in]   RestEx                The REST EX protocol on the child.
+
+  @retval EFI_SUCCESS           The child was destroyed.
+  @retval Others                Failed to destroy the child.
+
+**/
+EFI_STATUS
+RedfishDestroyRestExChild (
+  IN EFI_HANDLE              Image,
+  IN EFI_HANDLE              Controller,
+  IN EFI_HANDLE              ChildHandle,
+  IN EFI_REST_EX_PROTOCOL    *RestEx
+  )
+{
+  EFI_STATUS                        Status;
+
+  Status = EFI_SUCCESS;
+
+  if (RestEx != NULL) {
+    gBS->CloseProtocol (
+           ChildHandle,
+           &gEfiRestExProtocolGuid,
+           Image,
+           Controller
+           );
+  }
+
+  if (ChildHandle != NULL) {
+    NetLibDestroyServiceChild (
+      Controller,
+      Image,
+      &gEfiRestExServiceBindingProtocolGuid,
+      ChildHandle
+      );
+  }
+
+  return Status;
+}
+
+/**
+  Create a child of the REST EX service.
+
+  This is a helper function to implement driver binding and service binding protocols.
+  This function will also check if the REST EX protocol instance is a preferred one.
+
+  If ChildHandle is NULL, then ASSERT().
+  If RestEx is NULL, then ASSERT().
+
+  @param[in]       Image                 The image handle used to open service.
+  @param[in]       Controller            The controller which has the REST EX service installed.
+  @param[in, out]  ChildHandle           The handle to receive the created child.
+  @param[out]      RestEx                The REST EX protocol on the new created child.
+
+
+  @retval EFI_SUCCESS           The child was successfully created.
+  @retval Others                Failed to create the child.
+
+**/
+EFI_STATUS
+RedfishCreateRestExChild (
+  IN      EFI_HANDLE              Image,
+  IN      EFI_HANDLE              Controller,
+  IN OUT  EFI_HANDLE              *ChildHandle,
+  OUT     EFI_REST_EX_PROTOCOL    **RestEx
+  )
+{
+  EFI_STATUS                        Status;
+  EFI_REST_EX_PROTOCOL              *RestExProtocol;
+
+  ASSERT (ChildHandle != NULL);
+  ASSERT (RestEx != NULL);
+
+  RestExProtocol    = NULL;
+
+  //
+  // Create a underlayer child instance.
+  //
+  Status = NetLibCreateServiceChild (
+             Controller,
+             Image,
+             &gEfiRestExServiceBindingProtocolGuid,
+             ChildHandle
+             );
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  //
+  // Open ChildHandle via BY_DRIVER.
+  // This is to establish the relationship between ControllerHandle and ChildHandle.
+  // Therefore, when DisconnectController(), RestConfigurationDriverBindingStop() will be called.
+  //
+  Status = gBS->OpenProtocol (
+                  *ChildHandle,
+                  &gEfiRestExProtocolGuid,
+                  &RestExProtocol,
+                  Image,
+                  Controller,
+                  EFI_OPEN_PROTOCOL_BY_DRIVER
+                  );
+  if (EFI_ERROR (Status)) {
+    goto ON_ERROR;
+  }
+
+  *RestEx = RestExProtocol;
+
+  return EFI_SUCCESS;
+
+ON_ERROR:
+
+  RedfishDestroyRestExChild (
+    Image,
+    Controller,
+    *ChildHandle,
+    RestExProtocol
+    );
+
+  return Status;
+}
+
+/**
+  Converts the Unicode string to ASCII string to a new allocated buffer.
+
+  @param[in]       String       Unicode string to be converted.
+
+  @return     Buffer points to ASCII string, or NULL if error happens.
+
+**/
+
+CHAR8 *
+UnicodeStrDupToAsciiStr (
+  CONST CHAR16 *String
+  )
+{
+  CHAR8      *AsciiStr;
+  UINTN      BufLen;
+  EFI_STATUS Status;
+
+  BufLen = StrLen (String) + 1;
+  AsciiStr = AllocatePool (BufLen);
+  if (AsciiStr == NULL) {
+    return NULL;
+  }
+
+  Status = UnicodeStrToAsciiStrS (String, AsciiStr, BufLen);
+  if (EFI_ERROR (Status)) {
+    return NULL;
+  }
+
+  return AsciiStr;
+}
+
+/**
+  Create a HTTP URL string for specific Redfish resource.
+
+  This function build a URL string from the Redfish Host interface record and caller specified
+  relative path of the resource.
+
+  Callers are responsible for freeing the returned string storage pointed by HttpUrl.
+
+  @param[in]   RedfishData         Redfish network host interface record.
+  @param[in]   RelativePath        Relative path of a resource.
+  @param[out]  HttpUrl             The pointer to store the returned URL string.
+
+  @retval EFI_SUCCESS              Build the URL string successfully.
+  @retval EFI_INVALID_PARAMETER    RedfishData or HttpUrl is NULL.
+  @retval EFI_OUT_OF_RESOURCES     There are not enough memory resources.
+
+**/
+EFI_STATUS
+RedfishBuildUrl (
+  IN  REDFISH_OVER_IP_PROTOCOL_DATA *RedfishData,
+  IN  CHAR16                        *RelativePath,   OPTIONAL
+  OUT CHAR16                        **HttpUrl
+  )
+{
+  CHAR16                            *Url;
+  CHAR16                            *UrlHead;
+  UINTN                             UrlLength;
+  UINTN                             PathLen;
+  UINT8                             Buffer[8];
+  UINT8                             *Tmp;
+  CHAR16                            ServiceIpStr[sizeof"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"];
+
+  if ((RedfishData == NULL) || (HttpUrl == NULL)) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //
+  // RFC2616: http_URL = "http(s):" "//" host [ ":" port ] [ abs_path [ "?" query ]]
+  //
+  if (RelativePath == NULL) {
+    PathLen = 0;
+  } else {
+    PathLen = StrLen (RelativePath);
+  }
+  UrlLength = StrLen (HTTPS_FLAG) + StrLen (REDFISH_FIRST_URL) + 1 + sizeof(ServiceIpStr)/sizeof(CHAR16) + PathLen;
+  if (RedfishData->RedfishServiceIpPort != 0) {
+    UrlLength = UrlLength + 1 + 6;
+  }
+
+  Url = AllocateZeroPool (UrlLength * sizeof (CHAR16));
+  if (Url == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  UrlHead = Url;
+
+  //
+  // Copy "http://" or "https://" according RedfishServiceIpPort.
+  //
+  if (RedfishData->RedfishServiceIpPort != 443) {
+    StrCpyS (Url, StrLen (HTTPS_FLAG) + 1, HTTP_FLAG);
+    Url = Url + StrLen (HTTP_FLAG);
+  } else {
+    StrCpyS (Url, StrLen (HTTPS_FLAG) + 1, HTTPS_FLAG);
+    Url = Url + StrLen (HTTPS_FLAG);
+  }
+
+  //
+  // Copy RedfishServiceIpAddress
+  //
+  if (RedfishData->RedfishServiceIpAddressFormat == 0x01) {
+    UnicodeSPrint (
+      ServiceIpStr,
+      sizeof (ServiceIpStr),
+      L"%d.%d.%d.%d",
+      ((EFI_IPv4_ADDRESS *) (RedfishData->RedfishServiceIpAddress))->Addr[0],
+      ((EFI_IPv4_ADDRESS *) (RedfishData->RedfishServiceIpAddress))->Addr[1],
+      ((EFI_IPv4_ADDRESS *) (RedfishData->RedfishServiceIpAddress))->Addr[2],
+      ((EFI_IPv4_ADDRESS *) (RedfishData->RedfishServiceIpAddress))->Addr[3]
+      );
+  } else {
+    NetLibIp6ToStr (
+      (EFI_IPv6_ADDRESS *) (RedfishData->RedfishServiceIpAddress),
+      ServiceIpStr,
+      sizeof (ServiceIpStr)
+      );
+  }
+
+  StrCpyS (Url, sizeof(ServiceIpStr)/sizeof(CHAR16), ServiceIpStr);
+
+  Url = Url + StrLen (ServiceIpStr);
+
+  //
+  // Copy [":" port]
+  //
+  if (RedfishData->RedfishServiceIpPort != 0) {
+    *Url = L':';
+    Url++;
+
+    ZeroMem (Buffer, sizeof (Buffer));
+    NetLibUintnToAscDecWithFormat (
+      RedfishData->RedfishServiceIpPort,
+      Buffer,
+      6
+      );
+
+    //
+    // Skip '0' in port.
+    //
+    Tmp = Buffer;
+    while (*Tmp == '0') {
+      Tmp++;
+    }
+
+    AsciiStrToUnicodeStrS (Tmp, Url, UrlLength);
+
+    while (*Url != '\0') {
+      Url++;
+    }
+  }
+
+  //
+  // Copy abs_path
+  //
+  if (RelativePath != NULL && PathLen != 0 ) {
+    StrnCpyS (Url, UrlLength, RelativePath, PathLen);
+  }
+  *HttpUrl = UrlHead;
+  return EFI_SUCCESS;
+}
+
+redfishService* createServiceEnumerator(EFI_HANDLE Image, EFI_HANDLE Controller, REDFISH_OVER_IP_PROTOCOL_DATA *RedfishData, const char* rootUri, enumeratorAuthentication* auth, unsigned int flags)
+{
+  EFI_STATUS           Status;
+  CHAR16               *HttpUrl;
+  CHAR8                *AsciiHost;
+  EFI_HANDLE           ChildHandle;
+  EFI_REST_EX_PROTOCOL *RestEx;
+  redfishService       *ret;
+
+  HttpUrl = NULL;
+  AsciiHost = NULL;
+  ChildHandle = NULL;
+  RestEx = NULL;
+  ret = NULL;
+
+  Status = RedfishBuildUrl (RedfishData, NULL, &HttpUrl);
+  if (EFI_ERROR (Status)) {
+    goto ON_EXIT;
+  }
+
+  ASSERT (HttpUrl != NULL);
+
+  AsciiHost = UnicodeStrDupToAsciiStr (HttpUrl);
+  if (AsciiHost == NULL) {
+    goto ON_EXIT;
+  }
+
+  Status = RedfishCreateRestExChild (Image, Controller, &ChildHandle, &RestEx);
+  if (EFI_ERROR (Status)) {
+    goto ON_EXIT;
+  }
+
+  //
+  // Configure the EFI_REST_EX_PROTOCOL.
+  //
+  Status = RedfishConfigRestEx (RestEx, RedfishData, REDFISH_HTTP_RESPONSE_TIMEOUT);
+  if (EFI_ERROR (Status)) {
+    RedfishDestroyRestExChild (Image, Controller, ChildHandle, RestEx);
+    goto ON_EXIT;
+  }
+
+  if(auth == NULL)
+  {
+    ret = createServiceEnumeratorNoAuth(AsciiHost, rootUri, true, flags, RestEx);
+  }
+  else if(auth->authType == REDFISH_AUTH_BASIC)
+  {
+    ret = createServiceEnumeratorBasicAuth(AsciiHost, rootUri, auth->authCodes.userPass.username, auth->authCodes.userPass.password, flags, RestEx);
+  }
+  else if(auth->authType == REDFISH_AUTH_SESSION)
+  {
+    ret = createServiceEnumeratorSessionAuth(AsciiHost, rootUri, auth->authCodes.userPass.username, auth->authCodes.userPass.password, flags, RestEx);
+  }
+  else
+  {
+    RedfishDestroyRestExChild (Image, Controller, ChildHandle, RestEx);
+    goto ON_EXIT;
+  }
+
+  ret->Image = Image;
+  ret->Controller = Controller;
+  ret->ChildHandle = ChildHandle;
+
+ON_EXIT:
+  if (HttpUrl != NULL) {
+    FreePool (HttpUrl);
+  }
+
+  if (AsciiHost != NULL) {
+    FreePool (AsciiHost);
+  }
+
+  return ret;
+}
+
+json_t* getUriFromService(redfishService* service, const char* uri, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+  char* url;
+  json_t* ret;
+  HTTP_IO_HEADER                    *HttpIoHeader = NULL;
+  EFI_STATUS                        Status;
+  EFI_HTTP_REQUEST_DATA             *RequestData = NULL;
+  EFI_HTTP_MESSAGE                  *RequestMsg = NULL;
+  EFI_HTTP_MESSAGE                  ResponseMsg;
+
+  if(service == NULL || uri == NULL || StatusCode == NULL)
+  {
+      return NULL;
+  }
+
+  *StatusCode = NULL;
+
+  url = makeUrlForService(service, uri);
+  if(!url)
+  {
+      return NULL;
+  }
+
+  DEBUG((EFI_D_INFO, "libredfish: getUriFromService(): %a\n", url));
+
+  //
+  // Step 1: Create HTTP request message with 4 headers:
+  //
+  HttpIoHeader = HttpIoCreateHeader ((service->sessionToken || service->basicAuthStr) ? 5 : 4);
+  if (HttpIoHeader == NULL) {
+    ret = NULL;
+    goto ON_EXIT;
+  }
+
+  if(service->sessionToken)
+  {
+    Status = HttpIoSetHeader (HttpIoHeader, "X-Auth-Token", service->sessionToken);
+    ASSERT_EFI_ERROR (Status);
+  } else if (service->basicAuthStr) {
+    Status = HttpIoSetHeader (HttpIoHeader, "Authorization", service->basicAuthStr);
+    ASSERT_EFI_ERROR (Status);
+  }
+
+  Status = HttpIoSetHeader (HttpIoHeader, "Host", service->HostHeaderValue);
+  ASSERT_EFI_ERROR (Status);
+  Status = HttpIoSetHeader (HttpIoHeader, "OData-Version", "4.0");
+  ASSERT_EFI_ERROR (Status);
+  Status = HttpIoSetHeader (HttpIoHeader, "Accept", "application/json");
+  ASSERT_EFI_ERROR (Status);
+  Status = HttpIoSetHeader (HttpIoHeader, "User-Agent", "libredfish");
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // Step 2: build the rest of HTTP request info.
+  //
+  RequestData = AllocateZeroPool (sizeof (EFI_HTTP_REQUEST_DATA));
+  if (RequestData == NULL) {
+    ret = NULL;
+    goto ON_EXIT;
+  }
+
+  RequestData->Method = HttpMethodGet;
+  RequestData->Url = C8ToC16 (url);
+
+  //
+  // Step 3: fill in EFI_HTTP_MESSAGE
+  //
+  RequestMsg = AllocateZeroPool (sizeof (EFI_HTTP_MESSAGE));
+  if (RequestMsg == NULL) {
+    ret = NULL;
+    goto ON_EXIT;
+  }
+
+  RequestMsg->Data.Request = RequestData;
+  RequestMsg->HeaderCount  = HttpIoHeader->HeaderCount;
+  RequestMsg->Headers      = HttpIoHeader->Headers;
+
+  ZeroMem (&ResponseMsg, sizeof (ResponseMsg));
+
+  //
+  // Step 4: call RESTEx to get response from REST service.
+  //
+  Status = service->RestEx->SendReceive (service->RestEx, RequestMsg, &ResponseMsg);
+  if (EFI_ERROR (Status)) {
+    ret = NULL;
+    goto ON_EXIT;
+  }
+
+  //
+  // Step 5: Return the HTTP StatusCode and Body message.
+  //
+  if (ResponseMsg.Data.Response != NULL) {
+    *StatusCode = AllocateZeroPool (sizeof (EFI_HTTP_STATUS_CODE));
+    if (*StatusCode == NULL) {
+      ret = NULL;
+      goto ON_EXIT;
+    }
+
+    //
+    // The caller shall take the responsibility to free the buffer.
+    //
+    **StatusCode = ResponseMsg.Data.Response->StatusCode;
+  }
+
+  if (ResponseMsg.BodyLength != 0 && ResponseMsg.Body != NULL) {
+    ret = json_loadb (ResponseMsg.Body, ResponseMsg.BodyLength, 0, NULL);
+  } else {
+    //
+    // There is no message body returned from server.
+    //
+    ret = NULL;
+  }
+
+ON_EXIT:
+  if (url != NULL) {
+    free (url);
+  }
+
+  if (HttpIoHeader != NULL) {
+    HttpIoFreeHeader (HttpIoHeader);
+  }
+
+  if (RequestData != NULL) {
+    RestConfigFreeHttpRequestData (RequestData);
+  }
+
+  if (RequestMsg != NULL) {
+    FreePool (RequestMsg);
+  }
+
+  RestConfigFreeHttpMessage (&ResponseMsg, FALSE);
+
+  return ret;
+}
+
+json_t* patchUriFromService(redfishService* service, const char* uri, const char* content, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+  char*               url;
+  json_t*             ret;
+  HTTP_IO_HEADER                    *HttpIoHeader = NULL;
+  EFI_STATUS                        Status;
+  EFI_HTTP_REQUEST_DATA             *RequestData = NULL;
+  EFI_HTTP_MESSAGE                  *RequestMsg = NULL;
+  EFI_HTTP_MESSAGE                  ResponseMsg;
+  CHAR8                             ContentLengthStr[80];
+
+  if(service == NULL || uri == NULL || content == NULL || StatusCode == NULL)
+  {
+      return NULL;
+  }
+
+  *StatusCode = NULL;
+
+  url = makeUrlForService(service, uri);
+  if(!url)
+  {
+      return NULL;
+  }
+
+  DEBUG((EFI_D_INFO, "libredfish: patchUriFromService(): %a\n", url));
+
+  //
+  // Step 1: Create HTTP request message with 4 headers:
+  //
+  HttpIoHeader = HttpIoCreateHeader ((service->sessionToken || service->basicAuthStr) ? 7 : 6);
+  if (HttpIoHeader == NULL) {
+    ret = NULL;
+    goto ON_EXIT;
+  }
+
+  if(service->sessionToken)
+  {
+    Status = HttpIoSetHeader (HttpIoHeader, "X-Auth-Token", service->sessionToken);
+    ASSERT_EFI_ERROR (Status);
+  } else if (service->basicAuthStr) {
+    Status = HttpIoSetHeader (HttpIoHeader, "Authorization", service->basicAuthStr);
+    ASSERT_EFI_ERROR (Status);
+  }
+
+  Status = HttpIoSetHeader (HttpIoHeader, "Host", service->HostHeaderValue);
+  ASSERT_EFI_ERROR (Status);
+  Status = HttpIoSetHeader (HttpIoHeader, "Content-Type", "application/json");
+  ASSERT_EFI_ERROR (Status);
+  Status = HttpIoSetHeader (HttpIoHeader, "Accept", "application/json");
+  ASSERT_EFI_ERROR (Status);
+  Status = HttpIoSetHeader (HttpIoHeader, "User-Agent", "libredfish");
+  ASSERT_EFI_ERROR (Status);
+  AsciiSPrint(
+    ContentLengthStr,
+    sizeof (ContentLengthStr),
+    "%lu",
+    (UINT64) strlen(content)
+    );
+  Status = HttpIoSetHeader (HttpIoHeader, "Content-Length", ContentLengthStr);
+  ASSERT_EFI_ERROR (Status);
+  Status = HttpIoSetHeader (HttpIoHeader, "OData-Version", "4.0");
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // Step 2: build the rest of HTTP request info.
+  //
+  RequestData = AllocateZeroPool (sizeof (EFI_HTTP_REQUEST_DATA));
+  if (RequestData == NULL) {
+    ret = NULL;
+    goto ON_EXIT;
+  }
+
+  RequestData->Method = HttpMethodPatch;
+  RequestData->Url = C8ToC16 (url);
+
+  //
+  // Step 3: fill in EFI_HTTP_MESSAGE
+  //
+  RequestMsg = AllocateZeroPool (sizeof (EFI_HTTP_MESSAGE));
+  if (RequestMsg == NULL) {
+    ret = NULL;
+    goto ON_EXIT;
+  }
+
+  RequestMsg->Data.Request = RequestData;
+  RequestMsg->HeaderCount  = HttpIoHeader->HeaderCount;
+  RequestMsg->Headers      = HttpIoHeader->Headers;
+  RequestMsg->BodyLength   = strlen(content);
+  RequestMsg->Body         = (VOID*) content;
+
+  ZeroMem (&ResponseMsg, sizeof (ResponseMsg));
+
+  //
+  // Step 4: call RESTEx to get response from REST service.
+  //
+  Status = service->RestEx->SendReceive (service->RestEx, RequestMsg, &ResponseMsg);
+  if (EFI_ERROR (Status)) {
+    ret = NULL;
+    goto ON_EXIT;
+  }
+
+  //
+  // Step 5: Return the HTTP StatusCode and Body message.
+  //
+  if (ResponseMsg.Data.Response != NULL) {
+    *StatusCode = AllocateZeroPool (sizeof (EFI_HTTP_STATUS_CODE));
+    if (*StatusCode == NULL) {
+      ret = NULL;
+      goto ON_EXIT;
+    }
+
+    //
+    // The caller shall take the responsibility to free the buffer.
+    //
+    **StatusCode = ResponseMsg.Data.Response->StatusCode;
+  }
+
+
+  if (ResponseMsg.BodyLength != 0 && ResponseMsg.Body != NULL) {
+    ret = json_loadb (ResponseMsg.Body, ResponseMsg.BodyLength, 0, NULL);
+  } else {
+    //
+    // There is no message body returned from server.
+    //
+    ret = NULL;
+  }
+
+ON_EXIT:
+  if (url != NULL) {
+    free (url);
+  }
+
+  if (HttpIoHeader != NULL) {
+    HttpIoFreeHeader (HttpIoHeader);
+  }
+
+  if (RequestData != NULL) {
+    RestConfigFreeHttpRequestData (RequestData);
+  }
+
+  if (RequestMsg != NULL) {
+    FreePool (RequestMsg);
+  }
+
+  RestConfigFreeHttpMessage (&ResponseMsg, FALSE);
+
+  return ret;
+}
+
+json_t* postUriFromService(redfishService* service, const char* uri, const char* content, size_t contentLength, const char* contentType, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+  char*               url = NULL;
+  json_t*             ret;
+  HTTP_IO_HEADER                    *HttpIoHeader = NULL;
+  EFI_STATUS                        Status;
+  EFI_HTTP_REQUEST_DATA             *RequestData = NULL;
+  EFI_HTTP_MESSAGE                  *RequestMsg = NULL;
+  EFI_HTTP_MESSAGE                  ResponseMsg;
+  CHAR8                             ContentLengthStr[80];
+  EFI_HTTP_HEADER                   *HttpHeader = NULL;
+
+  ret = NULL;
+
+  if(service == NULL || uri == NULL || content == NULL || StatusCode == NULL)
+  {
+      return NULL;
+  }
+
+  *StatusCode = NULL;
+
+  url = makeUrlForService(service, uri);
+  if(!url)
+  {
+      return NULL;
+  }
+
+  DEBUG((EFI_D_INFO, "libredfish: postUriFromService(): %a\n", url));
+
+  if(contentLength == 0)
+  {
+      contentLength = strlen(content);
+  }
+
+  //
+  // Step 1: Create HTTP request message with 4 headers:
+  //
+  HttpIoHeader = HttpIoCreateHeader ((service->sessionToken || service->basicAuthStr) ? 7 : 6);
+  if (HttpIoHeader == NULL) {
+    goto ON_EXIT;
+  }
+
+  if(service->sessionToken)
+  {
+    Status = HttpIoSetHeader (HttpIoHeader, "X-Auth-Token", service->sessionToken);
+    ASSERT_EFI_ERROR (Status);
+  } else if (service->basicAuthStr) {
+    Status = HttpIoSetHeader (HttpIoHeader, "Authorization", service->basicAuthStr);
+    ASSERT_EFI_ERROR (Status);
+  }
+
+  if(contentType == NULL) {
+    Status = HttpIoSetHeader (HttpIoHeader, "Content-Type", "application/json");
+    ASSERT_EFI_ERROR (Status);
+  } else {
+    Status = HttpIoSetHeader (HttpIoHeader, "Content-Type", (CHAR8 *) contentType);
+    ASSERT_EFI_ERROR (Status);
+  }
+  Status = HttpIoSetHeader (HttpIoHeader, "Host", service->HostHeaderValue);
+  ASSERT_EFI_ERROR (Status);
+  Status = HttpIoSetHeader (HttpIoHeader, "Accept", "application/json");
+  ASSERT_EFI_ERROR (Status);
+  Status = HttpIoSetHeader (HttpIoHeader, "User-Agent", "libredfish");
+  ASSERT_EFI_ERROR (Status);
+  AsciiSPrint(
+    ContentLengthStr,
+    sizeof (ContentLengthStr),
+    "%lu",
+    (UINT64) contentLength
+    );
+  Status = HttpIoSetHeader (HttpIoHeader, "Content-Length", ContentLengthStr);
+  ASSERT_EFI_ERROR (Status);
+  Status = HttpIoSetHeader (HttpIoHeader, "OData-Version", "4.0");
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // Step 2: build the rest of HTTP request info.
+  //
+  RequestData = AllocateZeroPool (sizeof (EFI_HTTP_REQUEST_DATA));
+  if (RequestData == NULL) {
+    goto ON_EXIT;
+  }
+
+  RequestData->Method = HttpMethodPost;
+  RequestData->Url = C8ToC16 (url);
+
+  //
+  // Step 3: fill in EFI_HTTP_MESSAGE
+  //
+  RequestMsg = AllocateZeroPool (sizeof (EFI_HTTP_MESSAGE));
+  if (RequestMsg == NULL) {
+    goto ON_EXIT;
+  }
+
+  RequestMsg->Data.Request = RequestData;
+  RequestMsg->HeaderCount  = HttpIoHeader->HeaderCount;
+  RequestMsg->Headers      = HttpIoHeader->Headers;
+  RequestMsg->BodyLength   = contentLength;
+  RequestMsg->Body         = (VOID*) content;
+
+  ZeroMem (&ResponseMsg, sizeof (ResponseMsg));
+
+  //
+  // Step 4: call RESTEx to get response from REST service.
+  //
+  Status = service->RestEx->SendReceive (service->RestEx, RequestMsg, &ResponseMsg);
+  if (EFI_ERROR (Status)) {
+    goto ON_EXIT;
+  }
+
+  //
+  // Step 5: Return the HTTP StatusCode and Body message.
+  //
+  if (ResponseMsg.Data.Response != NULL) {
+    *StatusCode = AllocateZeroPool (sizeof (EFI_HTTP_STATUS_CODE));
+    if (*StatusCode == NULL) {
+      goto ON_EXIT;
+    }
+
+    //
+    // The caller shall take the responsibility to free the buffer.
+    //
+    **StatusCode = ResponseMsg.Data.Response->StatusCode;
+  }
+
+  if (ResponseMsg.BodyLength != 0 && ResponseMsg.Body != NULL) {
+    ret = json_loadb (ResponseMsg.Body, ResponseMsg.BodyLength, 0, NULL);
+  }
+
+  //
+  // Step 6: Parsing the HttpHeader to retrive the X-Auth-Token if the HTTP StatusCode is correct.
+  //
+  if (ResponseMsg.Data.Response->StatusCode == HTTP_STATUS_200_OK ||
+      ResponseMsg.Data.Response->StatusCode == HTTP_STATUS_204_NO_CONTENT) {
+    HttpHeader = HttpFindHeader (ResponseMsg.HeaderCount, ResponseMsg.Headers, "X-Auth-Token");
+    if (HttpHeader != NULL) {
+      if(service->sessionToken)
+      {
+          free(service->sessionToken);
+      }
+      service->sessionToken = AllocateCopyPool (AsciiStrSize (HttpHeader->FieldValue), HttpHeader->FieldValue);
+    }
+
+    /*
+    //
+    // Below opeation seems to be unnecessary.
+    // Besides, the FieldValue for the Location is the full HTTP URI (Http://0.0.0.0:5000/XXX), so we can't use it as the
+    // parameter of getUriFromService () directly.
+    //
+    HttpHeader = HttpFindHeader (ResponseMsg.HeaderCount, ResponseMsg.Headers, "Location");
+    if (HttpHeader != NULL) {
+      ret = getUriFromService(service, HttpHeader->FieldValue);
+      goto ON_EXIT;
+    }
+    */
+  }
+
+ON_EXIT:
+  if (url != NULL) {
+    free (url);
+  }
+
+  if (HttpIoHeader != NULL) {
+    HttpIoFreeHeader (HttpIoHeader);
+  }
+
+  if (RequestData != NULL) {
+    RestConfigFreeHttpRequestData (RequestData);
+  }
+
+  if (RequestMsg != NULL) {
+    FreePool (RequestMsg);
+  }
+
+  RestConfigFreeHttpMessage (&ResponseMsg, FALSE);
+
+  return ret;
+}
+
+json_t* deleteUriFromService(redfishService* service, const char* uri, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+  char*               url;
+  json_t*             ret;
+  HTTP_IO_HEADER                    *HttpIoHeader = NULL;
+  EFI_STATUS                        Status;
+  EFI_HTTP_REQUEST_DATA             *RequestData = NULL;
+  EFI_HTTP_MESSAGE                  *RequestMsg = NULL;
+  EFI_HTTP_MESSAGE                  ResponseMsg;
+
+  ret = NULL;
+
+  if(service == NULL || uri == NULL || StatusCode == NULL)
+  {
+      return NULL;
+  }
+
+  *StatusCode = NULL;
+
+  url = makeUrlForService(service, uri);
+  if(!url)
+  {
+      return NULL;
+  }
+
+  DEBUG((EFI_D_INFO, "libredfish: deleteUriFromService(): %a\n", url));
+
+  //
+  // Step 1: Create HTTP request message with 4 headers:
+  //
+  HttpIoHeader = HttpIoCreateHeader ((service->sessionToken || service->basicAuthStr) ? 4 : 3);
+  if (HttpIoHeader == NULL) {
+    ret = NULL;
+    goto ON_EXIT;
+  }
+
+  if(service->sessionToken)
+  {
+    Status = HttpIoSetHeader (HttpIoHeader, "X-Auth-Token", service->sessionToken);
+    ASSERT_EFI_ERROR (Status);
+  } else if (service->basicAuthStr) {
+    Status = HttpIoSetHeader (HttpIoHeader, "Authorization", service->basicAuthStr);
+    ASSERT_EFI_ERROR (Status);
+  }
+  Status = HttpIoSetHeader (HttpIoHeader, "Host", service->HostHeaderValue);
+  ASSERT_EFI_ERROR (Status);
+  Status = HttpIoSetHeader (HttpIoHeader, "User-Agent", "libredfish");
+  ASSERT_EFI_ERROR (Status);
+  Status = HttpIoSetHeader (HttpIoHeader, "OData-Version", "4.0");
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // Step 2: build the rest of HTTP request info.
+  //
+  RequestData = AllocateZeroPool (sizeof (EFI_HTTP_REQUEST_DATA));
+  if (RequestData == NULL) {
+    ret = NULL;
+    goto ON_EXIT;
+  }
+
+  RequestData->Method = HttpMethodDelete;
+  RequestData->Url = C8ToC16 (url);
+
+  //
+  // Step 3: fill in EFI_HTTP_MESSAGE
+  //
+  RequestMsg = AllocateZeroPool (sizeof (EFI_HTTP_MESSAGE));
+  if (RequestMsg == NULL) {
+    ret = NULL;
+    goto ON_EXIT;
+  }
+
+  RequestMsg->Data.Request = RequestData;
+  RequestMsg->HeaderCount  = HttpIoHeader->HeaderCount;
+  RequestMsg->Headers      = HttpIoHeader->Headers;
+
+  ZeroMem (&ResponseMsg, sizeof (ResponseMsg));
+
+  //
+  // Step 4: call RESTEx to get response from REST service.
+  //
+  Status = service->RestEx->SendReceive (service->RestEx, RequestMsg, &ResponseMsg);
+  if (EFI_ERROR (Status)) {
+    ret = NULL;
+    goto ON_EXIT;
+  }
+
+  //
+  // Step 5: Return the HTTP StatusCode and Body message.
+  //
+  if (ResponseMsg.Data.Response != NULL) {
+    *StatusCode = AllocateZeroPool (sizeof (EFI_HTTP_STATUS_CODE));
+    if (*StatusCode == NULL) {
+      ret = NULL;
+      goto ON_EXIT;
+    }
+
+    //
+    // The caller shall take the responsibility to free the buffer.
+    //
+    **StatusCode = ResponseMsg.Data.Response->StatusCode;
+  }
+
+  if (ResponseMsg.BodyLength != 0 && ResponseMsg.Body != NULL) {
+    ret = json_loadb (ResponseMsg.Body, ResponseMsg.BodyLength, 0, NULL);
+  }
+
+ON_EXIT:
+  if (url != NULL) {
+    free (url);
+  }
+
+  if (HttpIoHeader != NULL) {
+    HttpIoFreeHeader (HttpIoHeader);
+  }
+
+  if (RequestData != NULL) {
+    RestConfigFreeHttpRequestData (RequestData);
+  }
+
+  if (RequestMsg != NULL) {
+    FreePool (RequestMsg);
+  }
+
+  RestConfigFreeHttpMessage (&ResponseMsg, FALSE);
+
+  return ret;
+}
+
+redfishPayload* getRedfishServiceRoot(redfishService* service, const char* version, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+    json_t* value;
+    json_t* versionNode;
+    const char* verUrl;
+
+    if(version == NULL)
+    {
+        versionNode = json_object_get(service->versions, "v1");
+    }
+    else
+    {
+        versionNode = json_object_get(service->versions, version);
+    }
+    if(versionNode == NULL)
+    {
+        return NULL;
+    }
+    verUrl = json_string_value(versionNode);
+    if(verUrl == NULL)
+    {
+        return NULL;
+    }
+    value = getUriFromService(service, verUrl, StatusCode);
+    if(value == NULL)
+    {
+        if((service->flags & REDFISH_FLAG_SERVICE_NO_VERSION_DOC) == 0)
+        {
+            json_decref(versionNode);
+        }
+        return NULL;
+    }
+    return createRedfishPayload(value, service);
+}
+
+redfishPayload* getPayloadByPath(redfishService* service, const char* path, EFI_HTTP_STATUS_CODE** StatusCode)
+{
+    redPathNode* redpath;
+    redfishPayload* root;
+    redfishPayload* ret;
+
+    if(!service || !path || StatusCode == NULL)
+    {
+        return NULL;
+    }
+
+    *StatusCode = NULL;
+
+    redpath = parseRedPath(path);
+    if(!redpath)
+    {
+        return NULL;
+    }
+    if(!redpath->isRoot)
+    {
+        cleanupRedPath(redpath);
+        return NULL;
+    }
+    root = getRedfishServiceRoot(service, redpath->version, StatusCode);
+    if (*StatusCode == NULL || **StatusCode < HTTP_STATUS_200_OK || **StatusCode > HTTP_STATUS_206_PARTIAL_CONTENT) {
+      cleanupRedPath(redpath);
+      return root;
+    }
+
+    if(redpath->next == NULL)
+    {
+        cleanupRedPath(redpath);
+        return root;
+    }
+
+    FreePool (*StatusCode);
+    *StatusCode = NULL;
+
+    ret = getPayloadForPath(root, redpath->next, StatusCode);
+    if (*StatusCode == NULL && ret != NULL) {
+      //
+      // In such a case, the Redfish resource is parsed from the input payload (root) directly.
+      // So, we still return HTTP_STATUS_200_OK.
+      //
+      *StatusCode = AllocateZeroPool (sizeof (EFI_HTTP_STATUS_CODE));
+      if (*StatusCode == NULL) {
+        ret = NULL;
+      } else {
+        **StatusCode = HTTP_STATUS_200_OK;
+      }
+    }
+    cleanupPayload(root);
+    cleanupRedPath(redpath);
+    return ret;
+}
+
+void cleanupServiceEnumerator(redfishService* service)
+{
+  if(!service)
+  {
+      return;
+  }
+  free(service->host);
+  json_decref(service->versions);
+  if(service->sessionToken != NULL)
+  {
+      ZeroMem (service->sessionToken, (UINTN)strlen(service->sessionToken));
+      FreePool(service->sessionToken);
+  }
+  if (service->basicAuthStr != NULL) {
+      ZeroMem (service->basicAuthStr, (UINTN)strlen(service->basicAuthStr));
+      FreePool (service->basicAuthStr);
+  }
+
+  if (service->RestEx != NULL && service->ChildHandle != NULL) {
+    RedfishDestroyRestExChild (
+      service->Image,
+      service->Controller,
+      service->ChildHandle,
+      service->RestEx
+      );
+  }
+
+  free(service);
+}
+
+static int initRest(redfishService* service, void * restProtocol)
+{
+  service->RestEx = restProtocol;
+  return 0;
+}
+
+static redfishService* createServiceEnumeratorNoAuth(const char* host, const char* rootUri, bool enumerate, unsigned int flags, void * restProtocol)
+{
+    redfishService* ret;
+    char  *HostStart;
+
+    ret = (redfishService*)calloc(1, sizeof(redfishService));
+    ZeroMem (ret, sizeof(redfishService));
+    if(initRest(ret, restProtocol) != 0)
+    {
+        free(ret);
+        return NULL;
+    }
+    ret->host = AllocateCopyPool(AsciiStrSize(host), host);
+    ret->flags = flags;
+    if(enumerate)
+    {
+        ret->versions = getVersions(ret, rootUri);
+    }
+    HostStart = strstr (ret->host, "//");
+    if (HostStart != NULL && (*(HostStart + 2) != '\0')) {
+      ret->HostHeaderValue = HostStart + 2;
+    }
+
+    return ret;
+}
+
+EFI_STATUS
+createBasicAuthStr (
+  IN  redfishService*                         service,
+  IN  CONST CHAR8                             *UserId,
+  IN  CONST CHAR8                             *Password
+  )
+{
+  EFI_STATUS                        Status;
+  CHAR8                             *RawAuthValue;
+  UINTN                             RawAuthBufSize;
+  CHAR8                             *EnAuthValue;
+  UINTN                             EnAuthValueSize;
+  CHAR8                             *BasicWithEnAuthValue;
+  UINTN                             BasicBufSize;
+
+  EnAuthValue     = NULL;
+  EnAuthValueSize = 0;
+
+  RawAuthBufSize = AsciiStrLen (UserId) + AsciiStrLen (Password) + 2;
+  RawAuthValue = AllocatePool (RawAuthBufSize);
+  if (RawAuthValue == NULL) {
+    return EFI_OUT_OF_RESOURCES;
+  }
+
+  //
+  // Build raw AuthValue (UserId:Password).
+  //
+  AsciiSPrint (
+    RawAuthValue,
+    RawAuthBufSize,
+    "%a:%a",
+    UserId,
+    Password
+    );
+
+  //
+  // Encoding RawAuthValue into Base64 format.
+  //
+  Status = HttpBase64Encode (
+             (CONST VOID *) RawAuthValue,
+             AsciiStrLen (RawAuthValue),
+             (UINT8 *) EnAuthValue,
+             &EnAuthValueSize
+             );
+  if (Status == EFI_BUFFER_TOO_SMALL) {
+    EnAuthValue = (CHAR8 *) AllocateZeroPool (EnAuthValueSize);
+    if (EnAuthValue == NULL) {
+      Status = EFI_OUT_OF_RESOURCES;
+      return Status;
+    }
+
+    Status = HttpBase64Encode (
+               (CONST VOID *) RawAuthValue,
+               AsciiStrLen (RawAuthValue),
+               (UINT8 *) EnAuthValue,
+               &EnAuthValueSize
+               );
+  }
+
+  if (EFI_ERROR (Status)) {
+    goto Exit;
+  }
+
+  BasicBufSize = AsciiStrLen ("Basic ") + AsciiStrLen(EnAuthValue) + 2;
+  BasicWithEnAuthValue = AllocatePool (BasicBufSize);
+  if (BasicWithEnAuthValue == NULL) {
+    Status = EFI_OUT_OF_RESOURCES;
+    goto Exit;
+  }
+
+  //
+  // Build encoded EnAuthValue with Basic (Basic EnAuthValue).
+  //
+  AsciiSPrint (
+    BasicWithEnAuthValue,
+    BasicBufSize,
+    "%a %a",
+    "Basic",
+    EnAuthValue
+    );
+
+  service->basicAuthStr = BasicWithEnAuthValue;
+
+Exit:
+  if (RawAuthValue != NULL) {
+    ZeroMem (RawAuthValue, RawAuthBufSize);
+    FreePool (RawAuthValue);
+  }
+
+  if (EnAuthValue != NULL) {
+    ZeroMem (EnAuthValue, EnAuthValueSize);
+    FreePool (EnAuthValue);
+  }
+
+  return Status;
+}
+
+static redfishService* createServiceEnumeratorBasicAuth(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, void * restProtocol)
+{
+    redfishService* ret;
+    EFI_STATUS   Status;
+
+    ret = createServiceEnumeratorNoAuth(host, rootUri, false, flags, restProtocol);
+
+    // add basic auth str
+    Status = createBasicAuthStr (ret, username, password);
+    if (EFI_ERROR(Status)) {
+      cleanupServiceEnumerator (ret);
+      return NULL;
+    }
+
+    ret->versions = getVersions(ret, rootUri);
+    return ret;
+}
+
+static redfishService* createServiceEnumeratorSessionAuth(const char* host, const char* rootUri, const char* username, const char* password, unsigned int flags, void * restProtocol)
+{
+    redfishService* ret;
+    redfishPayload* payload;
+    redfishPayload* links;
+    json_t* sessionPayload;
+    json_t* session;
+    json_t* odataId;
+    const char* uri;
+    json_t* post;
+    char* content;
+    EFI_HTTP_STATUS_CODE *StatusCode;
+
+    content = NULL;
+    StatusCode = NULL;
+
+    ret = createServiceEnumeratorNoAuth(host, rootUri, true, flags, restProtocol);
+    if(ret == NULL)
+    {
+        return NULL;
+    }
+    payload = getRedfishServiceRoot(ret, NULL, &StatusCode);
+    if(StatusCode == NULL || *StatusCode < HTTP_STATUS_200_OK || *StatusCode > HTTP_STATUS_206_PARTIAL_CONTENT)
+    {
+        if (StatusCode != NULL) {
+          FreePool (StatusCode);
+        }
+
+        if (payload != NULL) {
+          cleanupPayload(payload);
+        }
+        cleanupServiceEnumerator(ret);
+        return NULL;
+    }
+
+    if (StatusCode != NULL) {
+      FreePool (StatusCode);
+      StatusCode = NULL;
+    }
+
+    links = getPayloadByNodeName(payload, "Links", &StatusCode);
+    cleanupPayload(payload);
+    if(links == NULL)
+    {
+        cleanupServiceEnumerator(ret);
+        return NULL;
+    }
+    session = json_object_get(links->json, "Sessions");
+    if(session == NULL)
+    {
+        cleanupPayload(links);
+        cleanupServiceEnumerator(ret);
+        return NULL;
+    }
+    odataId = json_object_get(session, "@odata.id");
+    if(odataId == NULL)
+    {
+        cleanupPayload(links);
+        cleanupServiceEnumerator(ret);
+        return NULL;
+    }
+    uri = json_string_value(odataId);
+    post = json_object();
+    addStringToJsonObject(post, "UserName", username);
+    addStringToJsonObject(post, "Password", password);
+    content = json_dumps(post, 0);
+    json_decref(post);
+    sessionPayload = postUriFromService(ret, uri, content, 0, NULL, &StatusCode);
+
+    if (content != NULL) {
+      ZeroMem (content, (UINTN)strlen(content));
+      free(content);
+    }
+
+    if(sessionPayload == NULL || StatusCode == NULL || *StatusCode < HTTP_STATUS_200_OK || *StatusCode > HTTP_STATUS_206_PARTIAL_CONTENT)
+    {
+        //Failed to create session!
+
+        cleanupPayload(links);
+        cleanupServiceEnumerator(ret);
+
+        if (StatusCode != NULL) {
+          FreePool (StatusCode);
+        }
+
+        if (sessionPayload != NULL) {
+          json_decref(sessionPayload);
+        }
+
+        return NULL;
+    }
+    json_decref(sessionPayload);
+    cleanupPayload(links);
+    FreePool (StatusCode);
+    return ret;
+}
+
+static char* makeUrlForService(redfishService* service, const char* uri)
+{
+    char* url;
+    if(service->host == NULL)
+    {
+        return NULL;
+    }
+    url = (char*)malloc(strlen(service->host)+strlen(uri)+1);
+    strcpy(url, service->host);
+    strcat(url, uri);
+    return url;
+}
+
+static json_t* getVersions(redfishService* service, const char* rootUri)
+{
+    json_t*         ret = NULL;
+    EFI_HTTP_STATUS_CODE* StatusCode = NULL;
+
+    if(service->flags & REDFISH_FLAG_SERVICE_NO_VERSION_DOC)
+    {
+        service->versions = json_object();
+        if(service->versions == NULL)
+        {
+            return NULL;
+        }
+        addStringToJsonObject(service->versions, "v1", "/redfish/v1");
+        return service->versions;
+    }
+    if(rootUri != NULL)
+    {
+        ret = getUriFromService(service, rootUri, &StatusCode);
+    }
+    else
+    {
+        ret = getUriFromService(service, "/redfish", &StatusCode);
+    }
+
+    if (ret == NULL || StatusCode == NULL || *StatusCode < HTTP_STATUS_200_OK || *StatusCode > HTTP_STATUS_206_PARTIAL_CONTENT) {
+      if (ret != NULL) {
+        json_decref(ret);
+      }
+      ret = NULL;
+    }
+
+    if (StatusCode != NULL) {
+      FreePool (StatusCode);
+    }
+
+    return ret;
+}
+
+static void addStringToJsonObject(json_t* object, const char* key, const char* value)
+{
+    json_t* jValue = json_string(value);
+
+    json_object_set(object, key, jValue);
+
+    json_decref(jValue);
+}
diff --git a/src/redpath.c b/src/redpath.c
index cbe8979..b4adfbf 100644
--- a/src/redpath.c
+++ b/src/redpath.c
@@ -1,14 +1,24 @@
+/** @file
+
+  Copyright (c) 2019, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php.
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
 //----------------------------------------------------------------------------
 // Copyright Notice:
 // Copyright 2017 Distributed Management Task Force, Inc. All rights reserved.
 // License: BSD 3-Clause License. For full text see link: https://github.com/DMTF/libredfish/LICENSE.md
 //----------------------------------------------------------------------------
-#include <stdlib.h>
-#include <string.h>
-
-#include <redpath.h>
+#include <jansson.h>
+#include "..\include\redpath.h"
 
 static char* getVersion(const char* path, char** end);
 static void parseNode(const char* path, redPathNode* node, redPathNode** end);
 
 static char* getStringTill(const char* string, const char* terminator, char** retEnd);
@@ -130,11 +140,11 @@ static void parseNode(const char* path, redPathNode* node, redPathNode** end)
         free(index);
         node->next->index = tmpIndex;
         node->next->isIndex = true;
         return;
     }
-    opChars = strpbrk(index, "<>=");
+    opChars = strpbrk(index, "<>=~");
     if(opChars == NULL)
     {
         //TODO handle last() and position()
         node->next->op = strdup("exists");
         node->next->propName = index;
@@ -145,11 +155,11 @@ static void parseNode(const char* path, redPathNode* node, redPathNode** end)
     node->next->propName[(opChars - index)] = 0;
 
     tmpIndex = 1;
     while(1)
     {
-        if(opChars[tmpIndex] == '=' || opChars[tmpIndex] == '<' || opChars[tmpIndex] == '>')
+        if(opChars[tmpIndex] == '=' || opChars[tmpIndex] == '<' || opChars[tmpIndex] == '>' || opChars[tmpIndex] == '~')
         {
             tmpIndex++;
             continue;
         }
         break;
-- 
2.17.1.windows.2

